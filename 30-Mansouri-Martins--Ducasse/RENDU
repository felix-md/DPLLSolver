                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       

********** à remplir obligatoirement **********

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: le vendredi 25 octobre 2024 à 19:00

Identité
--------
Nombre de binôme: **30**
Nom, prénom 1: **Martins--Ducasse Félix**
Nom, prénom 2: **Mansouri Yanis**


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

**Make DPLL s'ecéxute sans erreurs ou warnings. ./dpll sudoku-4x4.cnf donne la réponse attendue.**

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

**Oui nous avons utilisé la fonction filter_map.
La fonction simplifie se fait en plusieurs étapes :
1 - On parcours récursivement les clauses
2 - Si on a fini, on renvoie notre accumulateur
3 - Sinon, si notre littéral est dans la clause, alors on n'ajoute pas cette clause a l'accumulateur. Sinon on filtre la clause en enlevant les négation du littéral si il y en a, puis on l'ajoute a l'accumulateur.**

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

**Pour notre implémentation de unitaire nous n'avons pas eu besoin de définir des fonctions auxiliaires ni d'utiliser des fonctions d'une bibliothèque. Un simple parcours avec un pattern matching suffit**


---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

**Pour notre implémentation de  pur nous avons utiliser les fonctions flatten et sort_uniq du module List ainsi que la fonction compare du module Int. En utilisant flatten, le parcours de tous les littéraux est plus simple. En retirant les doublons avec sort_uniq, ainsi qu'avec compare comme fonction de comparaison, le coût de la recherche de littéral pur est plus faible car la liste a parcourir est plus courte. Nous avons choisi d'utiliser le type option, pour de meilleures performances et un code plus élégant.**

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**Le fichier exemple-5-8.cnf ne donne pas le même résultat entre les deux fonction.
En effet solveur_split renvoie :
SAT
1 2 3 -4 6 8 9 0
et solveur_dpll_rec renvoie :
SAT
1 2 3 -4 -7 0
Cette différence s'explique par le choix des littéraux a simplifier, en effet le solveur_split va simplement prendre le premier littéral de la formule tandis que le solveur_dpll_rec va d'abord chercher les clauses unitaire, puis pur avant de mimer le comportement de solveur_split. Ainsi les interprétations trouvées peuvent différées.**

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**Notre programme est relativement optimisé si on se cantonne a l'utilisation de list classique Ocaml. En effet l'utilisation de HashMap permettrai des performance plus élevé grâce un temps d'accès moindre pour chercher les littéraux purs.
Tous les fichiers cnf SAT donnés se finissent en moins de 40 secondes tous cumulés sur nos machines**

---

--fin du fichier RENDU--