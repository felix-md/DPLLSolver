(* MP1 2024/2025 - dpll.ml *)

open List


(* fonctions utilitaires *)
(* ----------------------------------------------------------- *)
(* filter_map : ('a -> 'b option) -> 'a list -> 'b list
   disponible depuis la version 4.08.0 de OCaml dans le module List :
   pour chaque élément de `list', appliquer `filter' :
   - si le résultat est `Some e', ajouter `e' au résultat ;
   - si le résultat est `None', ne rien y ajouter.
   Attention, cette implémentation inverse l'ordre de la liste *)
let filter_map filter list =
  (* 10087645758 *) let rec aux list ret =
    (* 32380816670 *) match list with
    | []   -> (* 10087645758 *) ret
    | h::t -> (* 22293170912 *) match (filter h) with
      | None   -> (* 305549953 *) aux t ret
      | Some e -> (* 21987620959 *) aux t (e::ret)
  in aux list []

(* print_modele : int list option -> unit
   afficher le résultat *)
let print_modele: int list option -> unit = function
  | None   -> (* 0 *) print_string "UNSAT\n"
  | Some modele -> (* 7 *) print_string "SAT\n";
     let modele2 = sort (fun i j -> (* 16093 *) (abs i) - (abs j)) modele in
     List.iter (fun i -> (* 2294 *) print_int i; print_string " ") modele2;
     print_string "0\n"

(* ensembles de clauses de test *)
let exemple_3_12 = [[1;2;-3];[2;3];[-1;-2;3];[-1;-3];[1;-2]]
let exemple_7_2 = [[1;-1;-3];[-2;3];[-2]]
let exemple_7_4 = [[1;2;3];[-1;2;3];[3];[1;-2;-3];[-1;-2;-3];[-3]]
let exemple_7_8 = [[1;-2;3];[1;-3];[2;3];[1;-2]]
let systeme = [[-1;2];[1;-2];[1;-3];[1;2;3];[-1;-2]]
let coloriage = [
  [1;2;3];[4;5;6];[7;8;9];[10;11;12];[13;14;15];[16;17;18];
  [19;20;21];[-1;-2];[-1;-3];[-2;-3];[-4;-5];[-4;-6];[-5;-6];
  [-7;-8];[-7;-9];[-8;-9];[-10;-11];[-10;-12];[-11;-12];[-13;-14];
  [-13;-15];[-14;-15];[-16;-17];[-16;-18];[-17;-18];[-19;-20];
  [-19;-21];[-20;-21];[-1;-4];[-2;-5];[-3;-6];[-1;-7];[-2;-8];
  [-3;-9];[-4;-7];[-5;-8];[-6;-9];[-4;-10];[-5;-11];[-6;-12];
  [-7;-10];[-8;-11];[-9;-12];[-7;-13];[-8;-14];[-9;-15];[-7;-16];
  [-8;-17];[-9;-18];[-10;-13];[-11;-14];[-12;-15];[-13;-16];
  [-14;-17];[-15;-18]]

(* ----------------------------------------------------------- *)

(* simplifie : int -> int list list -> int list list 
   applique la simplification de l'ensemble des clauses en mettant
   le littéral l à vrai *)
let simplifie l clauses =
  (* on cré un alias f de notre fonction de filtre *)
  (* la fonction de filtre parcours une clause en enlevant
   les proposotion non(l) car elle sont forcement fausse *)
  (* 197116937 *) let f c = (* 10087645758 *) filter_map (fun x -> (* 22293170912 *) if x = -l then None else Some x) c in
  (* on cré une fonction auxiliaire qui va parcourir les clauses recursivement *)
  let rec aux l clauses acc = 
    
    (* 10648322068 *) match clauses with
    (* Quand on a fini, on renvoie notre accumulateur dans le bon sens *)
    | []   -> (* 184440533 *) List.rev acc
    | h::t -> 
              (* si l est dans la clause h alors on ne l'ajoute pas car elle est satisfaite *)
              (* 10463881535 *) if mem l h then aux l t acc
              else
              (* sinon on filtre la clause *)
              let h_simplified = f  h in 
              (* si la clause est vide, alors on renvoie une liste vide ce qui optimise l'algorithme *)
              if h_simplified = [] then [[]] 
              else 
              (* sinon on continue la simplification en mettant a jour notre accumulateur *)
              aux l t (h_simplified::acc)
             

  in aux l clauses []



(* solveur_split : int list list -> int list -> int list option
   exemple d'utilisation de `simplifie' *)
(* cette fonction ne doit pas être modifiée, sauf si vous changez 
   le type de la fonction simplifie *)
let rec solveur_split clauses interpretation =
  (* l'ensemble vide de clauses est satisfiable *)
  (* 0 *) if clauses = [] then Some interpretation else
  (* la clause vide n'est jamais satisfiable *)
  if mem [] clauses then None else
  (* branchement *) 
  let l = hd (hd clauses) in
  let branche = solveur_split (simplifie l clauses) (l::interpretation) in
  match branche with
  | None -> (* 0 *) solveur_split (simplifie (-l) clauses) ((-l)::interpretation)
  | _    -> (* 0 *) branche

(* tests *)
(* let () = print_modele (solveur_split systeme []) *)
(* let () = print_modele (solveur_split coloriage []) *)

(* solveur dpll récursif *)
(* ----------------------------------------------------------- *)

(* pur : int list list -> int option
    - si `clauses' contient au moins un littéral pur, retourne
      ce littéral ;
    - sinon, renvoie None *)
let pur clauses =
  (* On applatit la list de list en list *)
  (* On trie la liste et on enleve les doublons *)
  (* 12-704-502 *) let uniq_flatten = List.sort_uniq Int.compare (flatten clauses) in
  (* Fonction auxiliare qui permet de parcourir les éléments de uniq_flatten *)
  let rec aux acc = function
    (* Si on a parcouru tout les elements de uniq_flatten alors on renvoie None, on a pas trouvé de littéral pur *)
    | [] -> (* 12676748 *) None
    
    | h::t -> (* si le littéral a déjà été parcouru, on passe au littéral suivant*)
              (* 1375398 *) if List.mem (-h) acc then aux acc t 
              (* sinon on cherche sa négation, si elle est présente on ajoute ce littéral et sa négation
              aux littéraux  déjà parcouru *)
              else if List.mem (-(h)) uniq_flatten then aux (h::acc) t 
              (* sinon on renvoie le littéral car il est pur *)
              else Some h
  in aux uniq_flatten []



(* unitaire : int list list -> int option
- si `clauses' contient au moins une clause unitaire, retourne
le littéral de cette clause unitaire ;
- sinon, renvoie None *)
let rec unitaire clauses =
  (* 4506310526 *) match clauses with
  | []   -> (* 12704502 *) None
  (* Si une clause est de taille 1, alors elle est unitaire *)
  | [x]::t -> (* 171736031 *) Some x
  | _::t ->  (* 4321869993 *) unitaire t

(* solveur_dpll_rec : int list list -> int list -> int list option *)
let rec solveur_dpll_rec clauses interpretation =
  (* l'ensemble vide de clauses est satisfiable *)
  (* 197116944 *) if clauses = [] then Some interpretation else
  (* la clause vide n'est jamais satisfiable *)
  if clauses = [[]] then None else
  (* on cherche une clause unitaire *)
  let u = unitaire clauses in 
  match u with
    (* Si il y en a une on la met a vraie dans notre interpretation*)
    | Some lit -> (* 171736031 *) solveur_dpll_rec (simplifie lit clauses) (lit::interpretation)
    | None ->
      (* Si il n'y a pas de clause unitaire, on cherche une variable pur *)
      (* 12704502 *) let p = pur clauses in 
      (* Si il y en a une on la met a vraie dans notre interpretation*)
      match p with 
      | Some lit -> (* 27754 *) solveur_dpll_rec (simplifie lit clauses) (lit::interpretation)
      | None -> 
          (* Si il n'y a ni clause unitaire ni variable pur *)
          (* On prend la première variable de la liste *)
          (* 12676748 *) let l = hd ( hd clauses) in
          (* On la satisfait dans notre interpretation *)
          let branche = solveur_dpll_rec (simplifie l clauses) (l::interpretation) in
          match branche with
            (* Si la branche est insatisfiable, on satisfait son opposé *)
            | None -> (* 12676404 *) solveur_dpll_rec (simplifie (-l) clauses) ((-l)::interpretation)
            (* Sinon on retourne la branche *)
            | _    -> (* 344 *) branche

(* tests *)
(* ----------------------------------------------------------- *)
(* let () = print_modele (solveur_dpll_rec systeme []) *)
(* let () = print_modele (solveur_dpll_rec coloriage []) *)


let () =
  let clauses = Dimacs.parse Sys.argv.(1) in
  print_modele ((solveur_dpll_rec clauses) []);
  
